import React, { useState, useRef, useEffect, useCallback } from 'react';
import { 
  Pencil, 
  Square, 
  Circle, 
  Minus, 
  Eraser, 
  Undo, 
  Maximize, 
  Download, 
  Trash2, 
  Palette,
  Hand
} from 'lucide-react';

const TOOLS = {
  BRUSH: 'brush',
  RECT: 'rect',
  CIRCLE: 'circle',
  LINE: 'line',
  ERASER: 'eraser'
};

const COLORS = [
  '#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff', 
  '#ffff00', '#ff00ff', '#00ffff', '#ffa500', '#8b4513'
];

export default function App() {
  const [tool, setTool] = useState(TOOLS.BRUSH);
  const [color, setColor] = useState('#000000');
  const [brushSize, setBrushSize] = useState(5);
  const [history, setHistory] = useState([]);
  const [isDrawing, setIsDrawing] = useState(false);
  const [isGesturing, setIsGesturing] = useState(false);
  
  const canvasRef = useRef(null);
  const tempCanvasRef = useRef(null);
  const startPos = useRef({ x: 0, y: 0 });

  // Initialize Canvas with proper DPI
  useEffect(() => {
    const initCanvas = () => {
      const canvas = canvasRef.current;
      const tempCanvas = tempCanvasRef.current;
      const parent = canvas.parentElement;
      
      const width = parent.clientWidth;
      const height = parent.clientHeight;
      const dpr = window.devicePixelRatio || 1;

      [canvas, tempCanvas].forEach(c => {
        c.width = width * dpr;
        c.height = height * dpr;
        c.style.width = `${width}px`;
        c.style.height = `${height}px`;
        const ctx = c.getContext('2d');
        ctx.scale(dpr, dpr);
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
      });

      // White background for main canvas
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, width, height);
    };

    initCanvas();
    window.addEventListener('resize', initCanvas);
    return () => window.removeEventListener('resize', initCanvas);
  }, []);

  const getPointerPos = (e) => {
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    return {
      x: clientX - rect.left,
      y: clientY - rect.top
    };
  };

  const startDrawing = (e) => {
    const pos = getPointerPos(e);
    startPos.current = pos;
    setIsDrawing(true);
    
    // Save current state to history for Undo
    const canvas = canvasRef.current;
    setHistory(prev => [...prev.slice(-19), canvas.toDataURL()]);

    if (tool === TOOLS.BRUSH || tool === TOOLS.ERASER) {
      const ctx = canvasRef.current.getContext('2d');
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y);
    }
  };

  const draw = (e) => {
    if (!isDrawing) return;
    const pos = getPointerPos(e);
    const ctx = canvasRef.current.getContext('2d');
    const tempCtx = tempCanvasRef.current.getContext('2d');
    
    // Clear temp canvas for shapes
    tempCtx.clearRect(0, 0, tempCanvasRef.current.width, tempCanvasRef.current.height);
    
    tempCtx.strokeStyle = color;
    tempCtx.fillStyle = color;
    tempCtx.lineWidth = brushSize;
    ctx.strokeStyle = tool === TOOLS.ERASER ? '#ffffff' : color;
    ctx.lineWidth = brushSize;

    switch (tool) {
      case TOOLS.BRUSH:
      case TOOLS.ERASER:
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        break;
      case TOOLS.RECT:
        tempCtx.strokeRect(
          startPos.current.x, 
          startPos.current.y, 
          pos.x - startPos.current.x, 
          pos.y - startPos.current.y
        );
        break;
      case TOOLS.CIRCLE:
        const radius = Math.sqrt(
          Math.pow(pos.x - startPos.current.x, 2) + 
          Math.pow(pos.y - startPos.current.y, 2)
        );
        tempCtx.beginPath();
        tempCtx.arc(startPos.current.x, startPos.current.y, radius, 0, 2 * Math.PI);
        tempCtx.stroke();
        break;
      case TOOLS.LINE:
        tempCtx.beginPath();
        tempCtx.moveTo(startPos.current.x, startPos.current.y);
        tempCtx.lineTo(pos.x, pos.y);
        tempCtx.stroke();
        break;
      default:
        break;
    }
  };

  const stopDrawing = (e) => {
    if (!isDrawing) return;
    setIsDrawing(false);

    // Commit temp canvas to main canvas
    if (tool !== TOOLS.BRUSH && tool !== TOOLS.ERASER) {
      const ctx = canvasRef.current.getContext('2d');
      ctx.drawImage(tempCanvasRef.current, 0, 0, canvasRef.current.width / window.devicePixelRatio, canvasRef.current.height / window.devicePixelRatio);
      const tempCtx = tempCanvasRef.current.getContext('2d');
      tempCtx.clearRect(0, 0, tempCanvasRef.current.width, tempCanvasRef.current.height);
    }
  };

  const handleUndo = () => {
    if (history.length === 0) return;
    const lastState = history[history.length - 1];
    const img = new Image();
    img.src = lastState;
    img.onload = () => {
      const ctx = canvasRef.current.getContext('2d');
      ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
      ctx.drawImage(img, 0, 0, canvasRef.current.width / window.devicePixelRatio, canvasRef.current.height / window.devicePixelRatio);
      setHistory(prev => prev.slice(0, -1));
    };
  };

  const clearCanvas = () => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    setHistory([]);
  };

  const toggleFullScreen = () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  };

  const downloadImage = () => {
    const link = document.createElement('a');
    link.download = 'my-paint-drawing.png';
    link.href = canvasRef.current.toDataURL();
    link.click();
  };

  return (
    <div className="flex flex-col h-screen w-full bg-slate-900 overflow-hidden font-sans text-slate-200">
      {/* Header Bar */}
      <div className="flex items-center justify-between px-6 py-3 bg-slate-800 border-b border-slate-700">
        <div className="flex items-center gap-3">
          <div className="p-2 bg-indigo-600 rounded-lg">
            <Palette size={20} />
          </div>
          <h1 className="font-bold text-lg hidden sm:block">Canvas Pro</h1>
        </div>

        <div className="flex items-center gap-2">
          <button 
            onClick={handleUndo}
            className="p-2 hover:bg-slate-700 rounded-lg transition-colors"
            title="Undo"
          >
            <Undo size={20} />
          </button>
          <button 
            onClick={clearCanvas}
            className="p-2 hover:bg-red-900/30 text-red-400 rounded-lg transition-colors"
            title="Clear"
          >
            <Trash2 size={20} />
          </button>
          <div className="w-[1px] h-6 bg-slate-700 mx-1" />
          <button 
            onClick={toggleFullScreen}
            className="p-2 hover:bg-slate-700 rounded-lg transition-colors"
            title="Full Screen"
          >
            <Maximize size={20} />
          </button>
          <button 
            onClick={downloadImage}
            className="flex items-center gap-2 bg-indigo-600 hover:bg-indigo-500 px-4 py-2 rounded-lg transition-colors font-medium text-sm"
          >
            <Download size={18} />
            <span className="hidden sm:inline">Export</span>
          </button>
        </div>
      </div>

      <div className="flex flex-1 overflow-hidden">
        {/* Sidebar Toolkit */}
        <div className="w-16 sm:w-20 bg-slate-800 border-r border-slate-700 flex flex-col items-center py-6 gap-6 overflow-y-auto">
          <div className="flex flex-col gap-2">
            <ToolButton active={tool === TOOLS.BRUSH} onClick={() => setTool(TOOLS.BRUSH)} icon={<Pencil size={22} />} label="Brush" />
            <ToolButton active={tool === TOOLS.RECT} onClick={() => setTool(TOOLS.RECT)} icon={<Square size={22} />} label="Rect" />
            <ToolButton active={tool === TOOLS.CIRCLE} onClick={() => setTool(TOOLS.CIRCLE)} icon={<Circle size={22} />} label="Circle" />
            <ToolButton active={tool === TOOLS.LINE} onClick={() => setTool(TOOLS.LINE)} icon={<Minus size={22} />} label="Line" />
            <ToolButton active={tool === TOOLS.ERASER} onClick={() => setTool(TOOLS.ERASER)} icon={<Eraser size={22} />} label="Eraser" />
          </div>

          <div className="w-10 h-[1px] bg-slate-700" />

          <div className="flex flex-col gap-3">
            {COLORS.map(c => (
              <button
                key={c}
                onClick={() => setColor(c)}
                className={`w-8 h-8 rounded-full border-2 transition-transform hover:scale-110 ${color === c ? 'border-white scale-110 shadow-lg' : 'border-transparent'}`}
                style={{ backgroundColor: c }}
              />
            ))}
          </div>

          <div className="mt-auto flex flex-col items-center gap-4">
            <div className="relative group">
               <button 
                onClick={() => setIsGesturing(!isGesturing)}
                className={`p-3 rounded-xl transition-all ${isGesturing ? 'bg-orange-500 text-white shadow-orange-500/20 shadow-xl' : 'bg-slate-700 text-slate-400'}`}
              >
                <Hand size={24} />
              </button>
              <div className="absolute left-full ml-4 bottom-0 bg-slate-800 p-3 rounded-lg border border-slate-700 w-48 opacity-0 group-hover:opacity-100 pointer-events-none transition-opacity z-50 shadow-2xl">
                <p className="text-xs font-bold text-orange-400 mb-1">GESTURE MODE</p>
                <p className="text-[10px] leading-relaxed">Simulates Hand Tracking. In a production build, this connects to your webcam via MediaPipe.</p>
              </div>
            </div>
            
            <input 
              type="range" 
              min="1" 
              max="50" 
              value={brushSize} 
              onChange={(e) => setBrushSize(parseInt(e.target.value))}
              className="w-12 h-2 accent-indigo-500 rotate-[-90deg] cursor-pointer"
            />
          </div>
        </div>

        {/* Main Drawing Area */}
        <div className="flex-1 relative bg-slate-900 p-4 sm:p-8 cursor-crosshair overflow-hidden touch-none">
          <div className="relative w-full h-full bg-white rounded-xl shadow-2xl overflow-hidden ring-1 ring-slate-700">
            {/* Base Canvas */}
            <canvas
              ref={canvasRef}
              onMouseDown={startDrawing}
              onMouseMove={draw}
              onMouseUp={stopDrawing}
              onMouseLeave={stopDrawing}
              onTouchStart={startDrawing}
              onTouchMove={draw}
              onTouchEnd={stopDrawing}
              className="absolute inset-0"
            />
            {/* Preview Canvas (for shapes being dragged) */}
            <canvas
              ref={tempCanvasRef}
              className="absolute inset-0 pointer-events-none"
            />

            {/* Simulated Gesture Overlay */}
            {isGesturing && (
              <div className="absolute inset-0 bg-orange-500/5 pointer-events-none flex flex-col items-center justify-center border-4 border-orange-500/20 rounded-xl">
                 <div className="bg-orange-500 text-white px-4 py-2 rounded-full text-xs font-bold animate-pulse shadow-lg flex items-center gap-2">
                   <div className="w-2 h-2 bg-white rounded-full animate-ping" />
                   MEDIA-PIPE GESTURE ENGINE ACTIVE
                 </div>
              </div>
            )}
          </div>

          {/* Floating Info */}
          <div className="absolute bottom-12 right-12 flex gap-4 pointer-events-none opacity-50 sm:opacity-100">
            <div className="bg-slate-800/80 backdrop-blur px-3 py-1 rounded-md text-[10px] border border-slate-700">
              Tool: <span className="text-indigo-400 capitalize">{tool}</span>
            </div>
            <div className="bg-slate-800/80 backdrop-blur px-3 py-1 rounded-md text-[10px] border border-slate-700">
              Size: <span className="text-indigo-400">{brushSize}px</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

function ToolButton({ active, onClick, icon, label }) {
  return (
    <button
      onClick={onClick}
      className={`relative group p-3 rounded-xl transition-all ${active ? 'bg-indigo-600 text-white shadow-indigo-600/20 shadow-xl scale-110' : 'text-slate-400 hover:bg-slate-700 hover:text-white'}`}
    >
      {icon}
      <span className="absolute left-full ml-4 bg-slate-800 text-white text-[10px] px-2 py-1 rounded opacity-0 group-hover:opacity-100 pointer-events-none transition-opacity whitespace-nowrap z-50">
        {label}
      </span>
    </button>
  );
}
