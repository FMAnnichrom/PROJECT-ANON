<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sprite Walker: Wild Lands</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --game-bg: #2d5a27;
            --text-color: #ecf0f1;
            --ui-bg: rgba(20, 20, 20, 0.9);
            --accent: #e67e22;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        /* SCREENS */
        .screen-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.5s;
        }
        
        #game-over-screen { background: linear-gradient(135deg, #4b1313 0%, #000 100%); display: none; }

        .title-text {
            font-size: 3rem;
            color: #f1c40f;
            text-shadow: 0 4px 0 #d35400, 0 10px 20px rgba(0,0,0,0.5);
            margin-bottom: 20px;
            text-align: center;
            animation: float 3s ease-in-out infinite;
        }

        .subtitle { color: #bdc3c7; margin-bottom: 40px; font-size: 1.2rem; max-width: 600px; text-align: center; line-height: 1.5; }

        .big-btn {
            background: #27ae60;
            border: none;
            border-bottom: 5px solid #1e8449;
            color: white;
            padding: 15px 40px;
            font-size: 1.5rem;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.1s;
            text-transform: uppercase;
            font-weight: bold;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }
        .big-btn:active { transform: translateY(3px); border-bottom-width: 2px; }
        .big-btn:hover { background: #2ecc71; }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* GAME UI */
        #game-container {
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            border: 4px solid #3c2f2f;
            border-radius: 8px;
            background-color: var(--game-bg);
            image-rendering: pixelated; 
            overflow: hidden;
            width: 90vw;
            height: 70vh;
            max-width: 900px;
            max-height: 650px;
        }

        canvas { display: block; image-rendering: pixelated; }

        /* RPG HUD */
        #hud {
            position: absolute; top: 15px; left: 15px;
            display: flex; flex-direction: column; gap: 8px;
            pointer-events: none; z-index: 20; width: 250px;
        }
        .hud-row {
            display: flex; align-items: center;
            background: rgba(0,0,0,0.6); padding: 4px 8px;
            border-radius: 4px; border-left: 4px solid #7f8c8d;
        }
        .bar-container { flex-grow: 1; height: 12px; background: #333; margin-left: 8px; border-radius: 2px; overflow: hidden; }
        .bar-fill { height: 100%; background: #e74c3c; width: 100%; transition: width 0.2s; }
        .hud-icon { width: 20px; text-align: center; margin-right: 5px; font-size: 16px; }
        .hud-text { font-size: 14px; font-weight: bold; font-family: monospace; color: #fff; }

        /* Build Progress */
        #build-progress-bar {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            width: 200px; height: 24px; background: #222; border: 2px solid #fff; border-radius: 12px;
            overflow: hidden; display: none; z-index: 60; box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        #build-fill { width: 0%; height: 100%; background: linear-gradient(90deg, #f39c12, #e67e22); transition: width 0.1s linear; }
        #build-text { position: absolute; width: 100%; text-align: center; color: #fff; font-size: 12px; line-height: 24px; font-family: 'Segoe UI', monospace; font-weight: bold; text-shadow: 1px 1px 0 #000; }

        /* Action Menu */
        #action-menu {
            position: absolute;
            background: var(--ui-bg); border: 2px solid var(--accent);
            padding: 10px; border-radius: 8px;
            display: none; flex-direction: column; gap: 5px;
            z-index: 50; text-align: center; min-width: 140px;
            transform: translate(-50%, -100%);
        }
        .action-title { font-size: 0.9rem; color: #f1c40f; margin-bottom: 5px; text-transform: capitalize;}
        .action-btn {
            background: #34495e; border: 1px solid #7f8c8d; color: white;
            padding: 6px 12px; cursor: pointer; border-radius: 4px;
            font-size: 0.8rem; transition: 0.2s; margin-bottom: 2px;
        }
        .action-btn:hover { background: #2c3e50; border-color: #fff; }
        .action-btn.kill { border-color: #e74c3c; color: #fab1a0; }
        .action-btn.tame { border-color: #2ecc71; color: #a3e4d7; }
        .action-btn.ride { border-color: #3498db; color: #aed6f1; }
        
        /* Camp Controls */
        #camp-controls {
            position: absolute; bottom: 20px; right: 20px;
            display: flex; flex-direction: column; gap: 10px; z-index: 30; align-items: flex-end;
        }
        .camp-btn {
            background: #e67e22; border: 2px solid #d35400; color: #fff;
            padding: 10px 15px; font-weight: bold; border-radius: 8px;
            cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            font-size: 0.9rem; width: fit-content;
        }
        .camp-btn:hover { background: #d35400; transform: translateY(-1px); }
        .camp-btn:disabled { background: #7f8c8d; border-color: #95a5a6; cursor: not-allowed; opacity: 0.7; transform: none; }
        .camp-btn.secondary { background: #8e44ad; border-color: #6c3483; }
        .camp-btn.danger { background: #c0392b; border-color: #922b21; font-size: 0.8rem; padding: 8px 12px; }

        /* Toast */
        #toast {
            position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: white; padding: 8px 16px;
            border-radius: 20px; font-size: 0.9rem; opacity: 0;
            transition: opacity 0.5s; pointer-events: none; z-index: 60;
        }

        /* Mobile Controls */
        #dpad { display: none; position: absolute; bottom: 20px; left: 20px; width: 140px; height: 140px; z-index: 50; }
        #action-btn-mobile { display: none; position: absolute; bottom: 90px; right: 20px; width: 70px; height: 70px; background: rgba(231, 76, 60, 0.4); border: 2px solid rgba(255,255,255,0.4); border-radius: 50%; z-index: 50; }
        #action-btn-mobile:active { background: rgba(231, 76, 60, 0.7); }
        .dpad-btn { position: absolute; width: 45px; height: 45px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; }
        .dpad-btn:active { background: rgba(255, 255, 255, 0.3); }
        .up { top: 0; left: 47px; } .down { bottom: 0; left: 47px; } .left { top: 47px; left: 0; } .right { top: 47px; right: 0; }

        @media (max-width: 768px) {
            #dpad, #action-btn-mobile { display: block; }
            #char-select { display: none; }
            #camp-controls { bottom: auto; top: 60px; right: 10px; }
            .camp-btn { padding: 6px 10px; font-size: 0.8rem; }
        }
    </style>
</head>
<body>

    <!-- START SCREEN -->
    <div id="start-screen" class="screen-overlay">
        <h1 class="title-text">WILD LANDS</h1>
        <p class="subtitle">Survive the wild. Tame beasts. Build your camp.<br>Arrow Keys/WASD to Move. SPACE to Shoot/Stomp. F to Feed/Action.</p>
        <button class="big-btn" onclick="startGame()">Start Journey</button>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="game-over-screen" class="screen-overlay">
        <h1 class="title-text" style="color: #c0392b; text-shadow: 0 4px 0 #581818;">YOU DIED</h1>
        <p class="subtitle">The wild has claimed you.</p>
        <button class="big-btn" onclick="location.reload()">Try Again</button>
    </div>

    <div id="char-select" style="position: absolute; top: 10px; right: 10px; display:flex; gap:5px; z-index: 30;">
        <button class="action-btn" onclick="switchPlayer('commander')">Commander</button>
        <button class="action-btn" onclick="switchPlayer('minion')">Minion</button>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <!-- UI Elements -->
        <div id="build-progress-bar">
            <div id="build-fill"></div>
            <div id="build-text">BUILDING CAMP...</div>
        </div>

        <div id="hud">
            <div class="hud-row" style="border-color: #e74c3c;">
                <span class="hud-icon">‚ù§Ô∏è</span>
                <div class="bar-container"><div id="hp-bar" class="bar-fill" style="width: 100%;"></div></div>
            </div>
            <div class="hud-row" style="border-color: #d35400;">
                <span class="hud-icon">üçñ</span>
                <span id="meat-count" class="hud-text">0</span>
            </div>
            <div class="hud-row" style="border-color: #3498db; display:none;" id="buff-row">
                <span class="hud-icon">‚ö°</span>
                <span id="buff-text" class="hud-text">SPEED</span>
            </div>
        </div>

        <div id="camp-controls">
            <button id="btn-build-camp" class="camp-btn" onclick="startBuildCamp()">‚õ∫ Build Camp (5s)</button>
            <button id="btn-sleep" class="camp-btn secondary" style="display:none;" onclick="toggleSleep()">üí§ Sleep / Wake</button>
            <button id="btn-tear-camp" class="camp-btn danger" style="display:none;" onclick="startTearCamp()">‚ùå Tear Down (5s)</button>
        </div>

        <div id="action-menu">
            <div class="action-title" id="target-name">Wild Beast</div>
            <div id="downed-actions" style="display:none;">
                <button class="action-btn kill" onclick="handleAction('kill')">üî™ Kill & Loot</button>
                <button class="action-btn tame" onclick="handleAction('tame')">ü§ù Tame (40%)</button>
            </div>
            <div id="tamed-actions" style="display:none;">
                <button class="action-btn ride" onclick="handleAction('ride')">üêé Ride / Dismount</button>
            </div>
        </div>

        <div id="toast">Message</div>
    </div>

    <div id="dpad">
        <div class="dpad-btn up" data-key="ArrowUp"></div>
        <div class="dpad-btn down" data-key="ArrowDown"></div>
        <div class="dpad-btn left" data-key="ArrowLeft"></div>
        <div class="dpad-btn right" data-key="ArrowRight"></div>
    </div>
    <div id="action-btn-mobile" data-key="Space"></div>

<script>
/** ENGINE CONFIGURATION */
const CONFIG = {
    SCALE: 3, ANIM_SPEED: 12, BASE_SPEED: 1.1, WORLD_SIZE: 2500,
    SPAWN_COUNT: 40, TREE_COUNT: 150, ROCK_COUNT: 80,
    TAME_CHANCE: 0.40, AGGRO_DIST: 250, ATTACK_RANGE: 40, PET_DETECT: 400,
    LINE_SPACING: 45,
    BUILD_TIME: 300 // 300 frames @ 60fps = 5 seconds
};

const DIR = { DOWN: 0, LEFT: 1, RIGHT: 2, UP: 3 };
const STATE = { ROAM: 0, CHASE: 1, DOWNED: 2, TAMED: 3 };

const textures = {}; 
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let gameActive = false; 
let worldCanvas = null;

// --- TEXTURE GENERATION ---
function createTexture(key, width, height, drawFn) {
    const tCanvas = document.createElement('canvas'); tCanvas.width = width; tCanvas.height = height;
    drawFn(tCanvas.getContext('2d')); const img = new Image(); img.src = tCanvas.toDataURL();
    textures[key] = { img: img, w: width/4, h: height/4 };
}
function createSingleTexture(key, width, height, drawFn) {
    const tCanvas = document.createElement('canvas'); tCanvas.width = width; tCanvas.height = height;
    drawFn(tCanvas.getContext('2d')); const img = new Image(); img.src = tCanvas.toDataURL();
    textures[key] = { img: img, w: width, h: height };
}

function initTextures() {
    createTexture('commander', 64, 64, ctx => drawSoldier(ctx, true));
    createTexture('minion', 64, 64, ctx => drawSoldier(ctx, false));
    createTexture('cat', 64, 64, ctx => drawCat(ctx));
    createTexture('dog', 64, 64, ctx => drawDog(ctx));
    createTexture('lion', 128, 128, ctx => drawBigCat(ctx, 'lion'));
    createTexture('leopard', 128, 128, ctx => drawBigCat(ctx, 'leopard'));
    createTexture('elephant', 128, 128, ctx => drawElephant(ctx));
    createTexture('hippo', 128, 128, ctx => drawHippo(ctx));
    
    // Pixel art style environment
    createSingleTexture('tree', 48, 64, drawPixelTree);
    createSingleTexture('rock', 32, 32, drawPixelRock);
    createSingleTexture('meat', 16, 16, drawMeat);
    createSingleTexture('tent', 64, 64, drawPixelTent);
    createSingleTexture('bonfire', 32, 32, drawPixelBonfire);
    createSingleTexture('chair', 16, 16, drawPixelChair);
}

// Draw Functions
function drawSoldier(ctx, isC) { 
    const c = { a: '#95a5a6', ad: '#7f8c8d', s: '#f1c40f', p: '#34495e', sh: '#2c3e50', pl: isC?'#e74c3c':'#3498db' };
    for(let r=0;r<4;r++){ for(let l=0;l<4;l++){
        let x=l*16, y=r*16, dy=y-((l===1||l===3)?1:0);
        ctx.fillStyle='rgba(0,0,0,0.3)'; ctx.fillRect(x+4, y+14, 8, 2);
        ctx.fillStyle=c.a; ctx.fillRect(x+5, dy+9, 6, 4); ctx.fillStyle=c.s; ctx.fillRect(x+5, dy+5, 6, 4);
        ctx.fillStyle=c.ad; ctx.fillRect(x+4, dy+3, 8, 3); ctx.fillRect(x+4, dy+3, 1, 5); ctx.fillRect(x+11, dy+3, 1, 5);
        ctx.fillStyle=c.pl; ctx.fillRect(x+7, dy+1, 2, 2); ctx.fillRect(x+7, dy, 4, 1);
        let g='#bdc3c7';
        if(r===0) { ctx.fillStyle='#000'; ctx.fillRect(x+6, dy+6, 1, 1); ctx.fillRect(x+9, dy+6, 1, 1); ctx.fillStyle=g; ctx.fillRect(x+11, dy+10, 2, 2); ctx.fillRect(x+11, dy+12, 1, 2); }
        else if(r===3) { ctx.fillStyle=c.a; ctx.fillRect(x+5, dy+5, 6, 4); }
        else if(r===1) { ctx.fillStyle='#000'; ctx.fillRect(x+4, dy+6, 1, 1); ctx.fillStyle=g; ctx.fillRect(x+2, dy+10, 4, 2); ctx.fillRect(x+5, dy+11, 1, 2); }
        else if(r===2) { ctx.fillStyle='#000'; ctx.fillRect(x+11, dy+6, 1, 1); ctx.fillStyle=g; ctx.fillRect(x+10, dy+10, 4, 2); ctx.fillRect(x+10, dy+11, 1, 2); }
        ctx.fillStyle=c.sh; if(l===1) { ctx.fillRect(x+5, y+14, 2, 2); ctx.fillRect(x+10, y+15, 2, 1); } else if(l===3) { ctx.fillRect(x+6, y+15, 2, 1); ctx.fillRect(x+9, y+14, 2, 2); } else { ctx.fillRect(x+6, y+15, 2, 1); ctx.fillRect(x+9, y+15, 2, 1); }
    }}
}
function drawCat(ctx) { const c = { f: '#e67e22', w: '#fff', e: '#2c3e50' }; for(let r=0; r<4; r++) for(let l=0; l<4; l++){ let x=l*16, y=r*16, b=(l===1||l===3)?1:0; ctx.fillStyle=c.f; if(r!==3) ctx.fillRect(x+7, y+10-b, 2, 3); ctx.fillRect(x+5, y+10, 6, 4); ctx.fillRect(x+4, y+6-b, 8, 5); ctx.fillRect(x+4, y+4-b, 2, 2); ctx.fillRect(x+10, y+4-b, 2, 2); if(r!==3) { ctx.fillStyle=c.w; ctx.fillRect(x+7, y+9-b, 2, 1); ctx.fillStyle=c.e; if(r===1)ctx.fillRect(x+5, y+7-b, 1, 1); else if(r===2)ctx.fillRect(x+10, y+7-b, 1, 1); else {ctx.fillRect(x+5, y+7-b, 1, 1); ctx.fillRect(x+10, y+7-b, 1, 1);} } ctx.fillStyle=c.w; if(l===1){ctx.fillRect(x+4,y+14,2,1);ctx.fillRect(x+10,y+13,2,1);} else if(l===3){ctx.fillRect(x+4,y+13,2,1);ctx.fillRect(x+10,y+14,2,1);} else {ctx.fillRect(x+5,y+14,2,1);ctx.fillRect(x+9,y+14,2,1);} } }
function drawDog(ctx) { const c = { f: '#d35400', s: '#f1c40f', n: '#000' }; for(let r=0; r<4; r++) for(let l=0; l<4; l++){ let x=l*16, y=r*16, b=(l===1||l===3)?1:0; ctx.fillStyle=c.f; ctx.fillRect(x+11, y+(l%2===0?11:10), 2, 2); ctx.fillRect(x+4, y+10, 7, 4); ctx.fillRect(x+3, y+6-b, 8, 5); ctx.fillStyle='#a04000'; ctx.fillRect(x+2, y+7-b, 2, 3); ctx.fillRect(x+10, y+7-b, 2, 3); if(r!==3){ ctx.fillStyle=c.s; ctx.fillRect(x+5, y+9-b, 4, 2); ctx.fillStyle=c.n; ctx.fillRect(x+6, y+9-b, 2, 1); if(r===0){ctx.fillRect(x+4, y+7-b, 1, 1); ctx.fillRect(x+9, y+7-b, 1, 1);} } ctx.fillStyle=c.f; if(l===1){ctx.fillRect(x+4,y+14,2,1);ctx.fillRect(x+9,y+13,2,1);} else if(l===3){ctx.fillRect(x+4,y+13,2,1);ctx.fillRect(x+9,y+14,2,1);} else {ctx.fillRect(x+4,y+14,2,1);ctx.fillRect(x+9,y+14,2,1);} } }
function drawBigCat(ctx, type) { const isL = type === 'lion'; const c = isL ? { f: '#e67e22', l: '#f39c12', m: '#c0392b', n: '#000' } : { f: '#f1c40f', l: '#f39c12', s: '#000', n: '#000' }; for(let r=0; r<4; r++) for(let l=0; l<4; l++){ let x=l*32, y=r*32, dy=y+4; ctx.fillStyle='rgba(0,0,0,0.3)'; ctx.fillRect(x+6, y+26, 20, 4); ctx.fillStyle=c.f; ctx.fillRect(x+8, dy+10, 16, 12); if(!isL){ ctx.fillStyle=c.s; ctx.fillRect(x+6, dy+14, 2, 2); ctx.fillRect(x+14, dy+12, 2, 2); ctx.fillRect(x+10, dy+16, 2, 1); ctx.fillRect(x+18, dy+14, 2, 2); } if(isL){ ctx.fillStyle=c.m; ctx.fillRect(x+6, dy+2, 20, 14); } ctx.fillStyle=c.f; ctx.fillRect(x+10, dy+4, 12, 10); ctx.fillRect(x+9, dy+2, 3, 3); ctx.fillRect(x+20, dy+2, 3, 3); if(r===0){ ctx.fillStyle=c.l; ctx.fillRect(x+12, dy+10, 8, 4); ctx.fillStyle=c.n; ctx.fillRect(x+14, dy+10, 4, 2); ctx.fillRect(x+11, dy+7, 2, 2); ctx.fillRect(x+19, dy+7, 2, 2); } else if(r===1){ ctx.fillStyle=c.l; ctx.fillRect(x+8, dy+10, 4, 4); ctx.fillStyle=c.n; ctx.fillRect(x+7, dy+10, 2, 2); ctx.fillRect(x+11, dy+7, 2, 2); } else if(r===2){ ctx.fillStyle=c.l; ctx.fillRect(x+20, dy+10, 4, 4); ctx.fillStyle=c.n; ctx.fillRect(x+23, dy+10, 2, 2); ctx.fillRect(x+19, dy+7, 2, 2); } ctx.fillStyle=c.f; if(l===1){ ctx.fillRect(x+8, dy+20, 4, 6); ctx.fillRect(x+20, dy+18, 4, 6); } else if(l===3){ ctx.fillRect(x+8, dy+18, 4, 6); ctx.fillRect(x+20, dy+20, 4, 6); } else{ ctx.fillRect(x+8, dy+20, 4, 6); ctx.fillRect(x+20, dy+20, 4, 6); } } }
function drawElephant(ctx) { const c = { s: '#7f8c8d', l: '#95a5a6', t: '#fff' }; for(let r=0; r<4; r++) for(let l=0; l<4; l++){ let x=l*32, y=r*32, dy=y+2; ctx.fillStyle=c.s; ctx.fillRect(x+6, dy+8, 20, 16); ctx.fillRect(x+10, dy+4, 12, 10); if(r===0){ ctx.fillStyle=c.l; ctx.fillRect(x+4, dy+4, 6, 10); ctx.fillRect(x+22, dy+4, 6, 10); ctx.fillStyle=c.s; ctx.fillRect(x+(l%2===0?14:15), dy+14, 4, l%2===0?10:9); ctx.fillStyle=c.t; ctx.fillRect(x+12, dy+14, 2, 4); ctx.fillRect(x+18, dy+14, 2, 4); ctx.fillStyle='#000'; ctx.fillRect(x+11, dy+8, 2, 2); ctx.fillRect(x+19, dy+8, 2, 2); } else if(r===1){ ctx.fillStyle=c.l; ctx.fillRect(x+14, dy+6, 8, 10); ctx.fillStyle=c.s; ctx.fillRect(x+6, dy+12, 4, 10); ctx.fillStyle=c.t; ctx.fillRect(x+8, dy+14, 4, 2); ctx.fillStyle='#000'; ctx.fillRect(x+11, dy+8, 2, 2); } else if(r===2){ ctx.fillStyle=c.l; ctx.fillRect(x+10, dy+6, 8, 10); ctx.fillStyle=c.s; ctx.fillRect(x+22, dy+12, 4, 10); ctx.fillStyle=c.t; ctx.fillRect(x+20, dy+14, 4, 2); ctx.fillStyle='#000'; ctx.fillRect(x+19, dy+8, 2, 2); } else if(r===3){ ctx.fillStyle=c.l; ctx.fillRect(x+4, dy+4, 6, 10); ctx.fillRect(x+22, dy+4, 6, 10); } ctx.fillStyle=c.s; if(l===1){ ctx.fillRect(x+6, dy+22, 6, 4); ctx.fillRect(x+20, dy+20, 6, 4); } else if(l===3){ ctx.fillRect(x+6, dy+20, 6, 4); ctx.fillRect(x+20, dy+22, 6, 4); } else{ ctx.fillRect(x+6, dy+22, 6, 4); ctx.fillRect(x+20, dy+22, 6, 4); } } }
function drawHippo(ctx) { const c = { s: '#8e44ad', l: '#9b59b6', t: '#fff' }; for(let r=0; r<4; r++) for(let l=0; l<4; l++){ let x=l*32, y=r*32, dy=y+4; ctx.fillStyle=c.s; ctx.fillRect(x+4, dy+10, 24, 14); ctx.fillStyle=c.l; ctx.fillRect(x+8, dy+8, 16, 12); ctx.fillStyle=c.s; ctx.fillRect(x+8, dy+4, 16, 6); ctx.fillRect(x+9, dy+2, 2, 3); ctx.fillRect(x+21, dy+2, 2, 3); if(r===0){ ctx.fillStyle='#000'; ctx.fillRect(x+12, dy+16, 2, 2); ctx.fillRect(x+18, dy+16, 2, 2); ctx.fillRect(x+10, dy+8, 2, 2); ctx.fillRect(x+20, dy+8, 2, 2); ctx.fillStyle=c.t; ctx.fillRect(x+10, dy+19, 2, 3); ctx.fillRect(x+20, dy+19, 2, 3); } else if(r===1){ ctx.fillStyle=c.l; ctx.fillRect(x+4, dy+12, 6, 6); ctx.fillStyle='#000'; ctx.fillRect(x+5, dy+13, 2, 2); ctx.fillRect(x+11, dy+8, 2, 2); ctx.fillStyle=c.t; ctx.fillRect(x+4, dy+16, 2, 3); } else if(r===2){ ctx.fillStyle=c.l; ctx.fillRect(x+22, dy+12, 6, 6); ctx.fillStyle='#000'; ctx.fillRect(x+25, dy+13, 2, 2); ctx.fillRect(x+19, dy+8, 2, 2); ctx.fillStyle=c.t; ctx.fillRect(x+26, dy+16, 2, 3); } ctx.fillStyle=c.s; if(l===1){ ctx.fillRect(x+6, dy+20, 6, 4); ctx.fillRect(x+20, dy+22, 6, 4); } else if(l===3){ ctx.fillRect(x+6, dy+22, 6, 4); ctx.fillRect(x+20, dy+20, 6, 4); } else{ ctx.fillRect(x+6, dy+22, 6, 4); ctx.fillRect(x+20, dy+22, 6, 4); } } }

// Pixel Art Functions (Rect-based)
function drawPixelTree(ctx) {
    // 2D Style Tree
    ctx.fillStyle = '#5d4037'; ctx.fillRect(20, 44, 8, 16); // Trunk
    // Layers of leaves (Rectangles)
    ctx.fillStyle = '#1e8449'; 
    ctx.fillRect(10, 36, 28, 8); 
    ctx.fillRect(12, 28, 24, 8);
    ctx.fillRect(16, 20, 16, 8);
    ctx.fillStyle = '#2ecc71'; // Highlights
    ctx.fillRect(12, 36, 4, 4);
    ctx.fillRect(14, 28, 4, 4);
    ctx.fillRect(18, 20, 4, 4);
}
function drawPixelRock(ctx) {
    ctx.fillStyle = '#556'; ctx.fillRect(4, 12, 24, 16); // Base
    ctx.fillStyle = '#7f8c8d'; ctx.fillRect(4, 10, 24, 16); // Main
    ctx.fillStyle = '#95a5a6'; ctx.fillRect(6, 12, 8, 4); // Highlight
    ctx.fillStyle = '#222'; ctx.fillRect(4, 26, 24, 2); // Shadow
}
function drawMeat(ctx) { ctx.fillStyle = '#c0392b'; ctx.beginPath(); ctx.ellipse(8, 8, 6, 4, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#fff'; ctx.fillRect(4, 7, 2, 2); ctx.fillRect(12, 7, 2, 2); }
function drawPixelTent(ctx) {
    // 2D Tent
    ctx.fillStyle = '#1e8449'; ctx.beginPath(); ctx.moveTo(32, 10); ctx.lineTo(58, 54); ctx.lineTo(6, 54); ctx.fill(); // Main
    ctx.fillStyle = '#27ae60'; ctx.beginPath(); ctx.moveTo(32, 10); ctx.lineTo(48, 54); ctx.lineTo(16, 54); ctx.fill(); // Front Flap
    ctx.fillStyle = '#111'; ctx.beginPath(); ctx.moveTo(32, 54); ctx.lineTo(38, 54); ctx.lineTo(32, 25); ctx.lineTo(26, 54); ctx.fill(); // Open Door
}
function drawPixelBonfire(ctx) {
    // Logs
    ctx.fillStyle = '#5d4037'; ctx.fillRect(6, 24, 20, 4); ctx.fillRect(10, 20, 4, 12);
    // Fire (Pixelated)
    ctx.fillStyle = '#e67e22'; ctx.fillRect(12, 14, 8, 10); ctx.fillRect(10, 18, 12, 6);
    ctx.fillStyle = '#f1c40f'; ctx.fillRect(14, 16, 4, 6);
}
function drawPixelChair(ctx) {
    ctx.fillStyle = '#8d6e63'; 
    ctx.fillRect(4, 16, 8, 2); // Seat
    ctx.fillRect(4, 8, 2, 16); // Back/Leg
    ctx.fillRect(10, 16, 2, 8); // Front Leg
}

// ---------------------------------------------------------
// --- WORLD GEN & GAME OBJECTS ---
// ---------------------------------------------------------

function generateWorld() {
    worldCanvas = document.createElement('canvas'); worldCanvas.width = CONFIG.WORLD_SIZE; worldCanvas.height = CONFIG.WORLD_SIZE;
    const wCtx = worldCanvas.getContext('2d');
    wCtx.fillStyle = '#27ae60'; wCtx.fillRect(0, 0, CONFIG.WORLD_SIZE, CONFIG.WORLD_SIZE);
    
    // Noise
    for(let i=0; i<8000; i++) {
        wCtx.fillStyle = Math.random() > 0.5 ? '#2ecc71' : '#1e8449';
        wCtx.fillRect(Math.random()*CONFIG.WORLD_SIZE, Math.random()*CONFIG.WORLD_SIZE, 4, 4);
    }

    const obstacles = [];

    const placeStatic = (texName, count) => {
        const tex = textures[texName];
        let placed = 0;
        let attempts = 0;
        while(placed < count && attempts < count * 5) {
            let x = Math.random() * (CONFIG.WORLD_SIZE - tex.w*CONFIG.SCALE);
            let y = Math.random() * (CONFIG.WORLD_SIZE - tex.h*CONFIG.SCALE);
            
            // Check Spawn Distance
            if(Math.hypot(x-1000, y-1000) > 300) {
                // Check Overlap with other props
                let overlap = false;
                for(let o of obstacles) {
                    if (Math.hypot(x - o.x, y - o.y) < 60) { overlap = true; break; }
                }
                if (!overlap) {
                    wCtx.drawImage(tex.img, x, y, tex.w*CONFIG.SCALE, tex.h*CONFIG.SCALE);
                    obstacles.push({x, y});
                    placed++;
                }
            }
            attempts++;
        }
    };
    placeStatic('rock', CONFIG.ROCK_COUNT);
    placeStatic('tree', CONFIG.TREE_COUNT);
}

// CLASSES
class Bullet {
    constructor(x, y, dir) { this.x = x; this.y = y; this.dir = dir; this.w = 6; this.h = 6; this.speed = 10; this.life = 40; this.dead = false; }
    update() { if(this.dir===DIR.UP)this.y-=this.speed; if(this.dir===DIR.DOWN)this.y+=this.speed; if(this.dir===DIR.LEFT)this.x-=this.speed; if(this.dir===DIR.RIGHT)this.x+=this.speed; this.life--; if(this.life<=0)this.dead=true; }
    draw(ctx) { ctx.fillStyle = '#f1c40f'; ctx.fillRect(this.x, this.y, this.w, this.h); }
}
class Shockwave {
    constructor(x, y) { this.x = x; this.y = y; this.r = 10; this.maxR = 80; this.alpha = 1.0; this.dead = false; }
    update() { this.r += 5; this.alpha -= 0.08; if(this.alpha <= 0) this.dead = true; }
    draw(ctx) {
        ctx.save(); ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255, 255, 255, ${this.alpha})`; ctx.lineWidth = 4; ctx.stroke(); ctx.restore();
    }
}
class Item {
    constructor(type, x, y) { this.type = type; this.x = x; this.y = y; this.w = 32; this.h = 32; this.tex = textures[type]; }
    draw(ctx) { ctx.drawImage(this.tex.img, this.x, this.y + Math.sin(Date.now()/200)*5, this.w, this.h); }
}

class Entity {
    constructor(type, x, y, isPassive) {
        this.type = type; this.x = x; this.y = y; this.tex = textures[type];
        this.w = this.tex.w * CONFIG.SCALE; this.h = this.tex.h * CONFIG.SCALE;
        this.dir = DIR.DOWN; this.frame = 0; this.timer = 0;
        this.state = STATE.ROAM; this.hp = 100; this.maxHp = 100;
        this.isPassive = isPassive; this.moveTimer = 0; this.target = null;
        this.attackCooldown = 0; this.aggroFlash = 0; this.woken = false;
        
        // Ride Stats
        this.canRide = ['lion','leopard','elephant','hippo'].includes(type);
        this.rideSpeed = 1.0;
        if (type === 'leopard') this.rideSpeed = 1.6; else if (type === 'lion') this.rideSpeed = 1.4; else if (type === 'elephant' || type === 'hippo') this.rideSpeed = 0.9;
    }

    getBounds() { return { x: this.x + this.w*0.2, y: this.y + this.h*0.2, w: this.w*0.6, h: this.h*0.6 }; }

    update() {
        if (this.state === STATE.DOWNED) return;
        
        // --- RIDING LOGIC ---
        if (player.riding === this) {
            this.frame = (player.isMoving) ? (Math.floor(Date.now() / (1000/CONFIG.ANIM_SPEED/2)) % 4) : 0; 
            return;
        }

        if (game.isNight && !this.woken) { this.frame = 0; return; }

        if (this.state === STATE.TAMED) {
            if (game.camp.active && Math.hypot(this.x - game.camp.x, this.y - game.camp.y) < 300) {
                this.roamBehavior(150, game.camp.x, game.camp.y);
                if (Math.hypot(this.x - (game.camp.x+40), this.y - (game.camp.y+60)) < 100) if (Math.random() < 0.05) this.hp = Math.min(this.hp + 1, this.maxHp);
            } else {
                let pack = entities.filter(e => e.state === STATE.TAMED);
                let myIdx = pack.indexOf(this);
                let followTarget = (myIdx === 0) ? player : pack[myIdx - 1];

                let nearestEnemy = null, minDist = CONFIG.PET_DETECT;
                entities.forEach(e => { if (e.state !== STATE.TAMED && e.state !== STATE.DOWNED && !e.isPassive) { let d = Math.hypot(this.x - e.x, this.y - e.y); if (d < minDist) { minDist = d; nearestEnemy = e; } } });

                if (nearestEnemy && minDist < 200) { this.moveTo(nearestEnemy.x, nearestEnemy.y); this.tryAttack(nearestEnemy); } 
                else {
                    let d = Math.hypot(followTarget.x - this.x, followTarget.y - this.y);
                    if (d > CONFIG.LINE_SPACING) this.moveTo(followTarget.x, followTarget.y);
                    else this.frame = 0;
                }
            }
            return;
        }

        if (this.target && this.target.hp > 0) {
            this.moveTo(this.target.x, this.target.y); this.tryAttack(this.target); this.aggroFlash = Math.max(0, this.aggroFlash - 1);
        } else {
            if (!this.isPassive && !this.target && Math.hypot(player.x - this.x, player.y - this.y) < CONFIG.AGGRO_DIST) {
                if (Math.random() < 0.01) { this.target = player; this.aggroFlash = 20; }
            }
            this.roamBehavior(0,0,0);
        }
    }

    roamBehavior(tetherRadius, tx, ty) {
        if (this.moveTimer <= 0) { this.isMoving = Math.random() > 0.4; this.dir = Math.floor(Math.random() * 4); this.moveTimer = 40 + Math.random() * 80; }
        this.moveTimer--;
        if (this.isMoving) {
            let speed = 1.0; let nx = this.x, ny = this.y;
            if (this.dir === DIR.UP) ny -= speed; if (this.dir === DIR.DOWN) ny += speed; if (this.dir === DIR.LEFT) nx -= speed; if (this.dir === DIR.RIGHT) nx += speed;
            if (tetherRadius > 0) { if (Math.hypot(nx - tx, ny - ty) < tetherRadius) { this.x = nx; this.y = ny; } else { this.dir = (this.dir + 2) % 4; } } 
            else { this.x = Math.max(0, Math.min(nx, CONFIG.WORLD_SIZE - this.w)); this.y = Math.max(0, Math.min(ny, CONFIG.WORLD_SIZE - this.h)); }
            this.updateAnim(true);
        } else { this.updateAnim(false); }
    }

    moveTo(tx, ty) {
        let angle = Math.atan2(ty - this.y, tx - this.x); let speed = CONFIG.BASE_SPEED * 1.1; 
        this.x += Math.cos(angle) * speed; this.y += Math.sin(angle) * speed;
        if(Math.abs(Math.cos(angle)) > Math.abs(Math.sin(angle))) this.dir = Math.cos(angle) > 0 ? DIR.RIGHT : DIR.LEFT;
        else this.dir = Math.sin(angle) > 0 ? DIR.DOWN : DIR.UP;
        this.updateAnim(true);
    }

    tryAttack(target) {
        if (this.attackCooldown > 0) { this.attackCooldown--; return; }
        let dist = Math.hypot((target.x + target.w/2) - (this.x + this.w/2), (target.y + target.h/2) - (this.y + this.h/2));
        if (dist < CONFIG.ATTACK_RANGE + 20) {
            if (target === player) {
                // If player is riding, mount takes damage!
                if (player.riding) {
                    player.riding.takeDamage(10, this);
                }
                else if (player.buffs.shield) { player.buffs.shield = false; showToast("Shield Blocked Attack!"); this.x -= Math.cos(Math.atan2(player.y-this.y, player.x-this.x)) * 50; } 
                else { player.hp -= 5; if(player.hp <= 0) gameOver(); }
            } else { target.takeDamage(10, this); }
            this.attackCooldown = 60;
        }
    }

    updateAnim(isMoving) { if (isMoving) { this.timer++; if (this.timer > CONFIG.ANIM_SPEED) { this.frame = (this.frame + 1) % 4; this.timer = 0; } } else { this.frame = 0; } }
    
    takeDamage(amt, attacker) {
        if (this.state === STATE.DOWNED) return;
        this.woken = true; if (attacker) this.target = attacker; else this.target = player; this.aggroFlash = 20;
        this.hp -= amt; if (this.hp <= 0) { this.hp = 0; this.state = STATE.DOWNED; this.target = null; if(player.riding===this) player.riding=null; showToast(`A ${this.type} is down!`); }
    }
    
    draw(ctx) {
        if (this.state === STATE.DOWNED) {
            ctx.save(); ctx.globalAlpha = 0.6; ctx.translate(this.x + this.w/2, this.y + this.h/2); ctx.rotate(Math.PI / 2);
            ctx.drawImage(this.tex.img, 0, 0, this.tex.w, this.tex.h, -this.w/2, -this.h/2, this.w, this.h);
            ctx.rotate(-Math.PI / 2); ctx.fillStyle = "#fff"; ctx.font = "20px Arial"; ctx.fillText("‚ùï", -10, -30); ctx.restore(); return;
        }
        const sx = this.frame * this.tex.w; const sy = this.dir * this.tex.h;
        if (this.target && this.state !== STATE.TAMED) { ctx.save(); ctx.globalAlpha = 0.5 + Math.sin(Date.now()/100)*0.3; ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(this.x+this.w/2, this.y+this.h, this.w/2, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
        ctx.drawImage(this.tex.img, sx, sy, this.tex.w, this.tex.h, this.x, this.y, this.w, this.h);
        if (game.isNight && !this.woken && this.state !== STATE.DOWNED) { ctx.fillStyle = "#111"; ctx.fillRect(this.x + this.w/2 - 6, this.y + 10, 4, 2); ctx.fillRect(this.x + this.w/2 + 2, this.y + 10, 4, 2); if (Math.floor(Date.now()/500)%2===0) { ctx.fillStyle = "#fff"; ctx.font="12px serif"; ctx.fillText("z", this.x+this.w, this.y); } }
        if (this.hp < this.maxHp) { ctx.fillStyle = 'red'; ctx.fillRect(this.x, this.y - 10, this.w, 5); ctx.fillStyle = '#2ecc71'; ctx.fillRect(this.x, this.y - 10, this.w * (this.hp/this.maxHp), 5); }
        if (this.state === STATE.TAMED) { ctx.fillStyle = '#3498db'; ctx.beginPath(); ctx.arc(this.x + this.w/2, this.y - 15, 4, 0, Math.PI*2); ctx.fill(); }
    }
}

// GAME & PLAYER
let game = { isNight: false, nightAlpha: 0, camp: { active: false, x: 0, y: 0, building: false, tearing: false, timer: 0 } };
let player = {
    x: 1000, y: 1000, w: 0, h: 0, type: 'commander', dir: DIR.DOWN, frame: 0, timer: 0, isMoving: false,
    hp: 100, maxHp: 100, inventory: { meat: 5 }, buffs: { regen: false, shield: false }, shootTimer: 0, riding: null
};
let entities = [], bullets = [], shockwaves = [], items = [], camera = { x: 0, y: 0 }, keys = {}, interactionTarget = null; 

function startGame() {
    document.getElementById('start-screen').style.display = 'none';
    gameActive = true;
    initGame();
}

function initGame() {
    initTextures(); resizeCanvas(); generateWorld(); updatePlayerSprite(); spawnEntities();
    window.addEventListener('resize', resizeCanvas); requestAnimationFrame(gameLoop);
    updateUI();
}
function resizeCanvas() { const c = document.getElementById('game-container'); canvas.width = c.clientWidth; canvas.height = c.clientHeight; ctx.imageSmoothingEnabled = false; }
function updatePlayerSprite() { const t = textures[player.type]; player.w = t.w * CONFIG.SCALE; player.h = t.h * CONFIG.SCALE; }
function switchPlayer(type) { player.type = type; updatePlayerSprite(); }
function spawnEntities() {
    entities = []; items = [];
    const hostiles = ['lion', 'leopard', 'elephant', 'hippo']; const passives = ['cat', 'dog'];
    for(let i=0; i<CONFIG.SPAWN_COUNT; i++) {
        let x, y, dist; do { x = Math.random()*(CONFIG.WORLD_SIZE-100); y = Math.random()*(CONFIG.WORLD_SIZE-100); dist = Math.hypot(x-1000, y-1000); } while(dist < 300);
        if (Math.random() < 0.2) entities.push(new Entity(passives[Math.floor(Math.random()*passives.length)], x, y, true));
        else entities.push(new Entity(hostiles[Math.floor(Math.random()*hostiles.length)], x, y, false));
    }
}

function update() {
    if (!gameActive) return;

    // Day/Night Cycle Smoothing
    let targetAlpha = game.isNight ? 0.6 : 0;
    game.nightAlpha += (targetAlpha - game.nightAlpha) * 0.05;

    // --- BUILDING LOGIC ---
    if (game.camp.building || game.camp.tearing) {
        game.camp.timer++;
        let progress = (game.camp.timer / CONFIG.BUILD_TIME) * 100;
        document.getElementById('build-progress-bar').style.display = 'block';
        document.getElementById('build-fill').style.width = progress + '%';
        document.getElementById('build-text').innerText = game.camp.building ? "BUILDING CAMP..." : "TEARING DOWN...";
        
        if (game.camp.timer >= CONFIG.BUILD_TIME) {
            if (game.camp.building) {
                game.camp.active = true; player.inventory.meat -= 5;
                showToast("Camp Built!");
            } else {
                game.camp.active = false; player.inventory.meat += 2;
                if(game.isNight) toggleSleep();
                showToast("Camp Removed (+2 Meat)");
            }
            game.camp.building = false; game.camp.tearing = false;
            document.getElementById('build-progress-bar').style.display = 'none';
            updateUI();
        }
        return; // FREEZE PLAYER WHILE BUILDING
    }

    player.isMoving = false;
    let speed = CONFIG.BASE_SPEED;

    // --- RIDING LOGIC ---
    if (player.riding) {
        let mount = player.riding;
        let rSpeed = speed * mount.rideSpeed;
        mount.isMoving = false;

        if (keys['ArrowUp'] || keys['KeyW']) { mount.y -= rSpeed; mount.dir = DIR.UP; mount.isMoving = true; }
        if (keys['ArrowDown'] || keys['KeyS']) { mount.y += rSpeed; mount.dir = DIR.DOWN; mount.isMoving = true; }
        if (keys['ArrowLeft'] || keys['KeyA']) { mount.x -= rSpeed; mount.dir = DIR.LEFT; mount.isMoving = true; }
        if (keys['ArrowRight'] || keys['KeyD']) { mount.x += rSpeed; mount.dir = DIR.RIGHT; mount.isMoving = true; }
        
        // Bounds for mount
        mount.x = Math.max(0, Math.min(mount.x, CONFIG.WORLD_SIZE - mount.w));
        mount.y = Math.max(0, Math.min(mount.y, CONFIG.WORLD_SIZE - mount.h));

        // Sync Player
        player.isMoving = mount.isMoving;
        player.dir = mount.dir;
        player.x = mount.x + mount.w/2 - player.w/2;
        player.y = mount.y - 15;
        
        if (keys['KeyR']) { handleAction('ride'); keys['KeyR'] = false; }
    } 
    // --- NORMAL MOVEMENT ---
    else {
        if (keys['ArrowUp'] || keys['KeyW']) { player.y -= speed; player.dir = DIR.UP; player.isMoving = true; }
        if (keys['ArrowDown'] || keys['KeyS']) { player.y += speed; player.dir = DIR.DOWN; player.isMoving = true; }
        if (keys['ArrowLeft'] || keys['KeyA']) { player.x -= speed; player.dir = DIR.LEFT; player.isMoving = true; }
        if (keys['ArrowRight'] || keys['KeyD']) { player.x += speed; player.dir = DIR.RIGHT; player.isMoving = true; }
        
        player.x = Math.max(0, Math.min(player.x, CONFIG.WORLD_SIZE - player.w));
        player.y = Math.max(0, Math.min(player.y, CONFIG.WORLD_SIZE - player.h));
        
        if (keys['KeyR']) {
            if (interactionTarget && interactionTarget.state === STATE.TAMED && interactionTarget.canRide) handleAction('ride');
            keys['KeyR'] = false; 
        }
    }

    if (player.isMoving) { player.timer++; if (player.timer > CONFIG.ANIM_SPEED) { player.frame = (player.frame + 1) % 4; player.timer = 0; } } else { player.frame = 0; }

    // ACTION (Shoot or Stomp)
    if (player.shootTimer > 0) player.shootTimer--;
    if ((keys['Space'] || keys['Enter']) && player.shootTimer <= 0) {
        if (player.riding) {
            // STOMP ATTACK
            let mx = player.riding.x + player.riding.w/2; let my = player.riding.y + player.riding.h/2;
            shockwaves.push(new Shockwave(mx, my));
            entities.forEach(e => {
                if (e !== player.riding && e.state !== STATE.TAMED && Math.hypot(e.x+e.w/2 - mx, e.y+e.h/2 - my) < 80) {
                    e.takeDamage(40, player);
                }
            });
            player.shootTimer = 60;
        } else {
            // SHOOT
            bullets.push(new Bullet(player.x + player.w/2, player.y + player.h/2, player.dir));
            player.shootTimer = 40; 
        }
    }
    
    // Camp Healing
    if (game.camp.active && Math.hypot(player.x - (game.camp.x+40), player.y - (game.camp.y+60)) < 100) {
        if (Math.random() < 0.05) player.hp = Math.min(player.hp + 1, 100);
        document.getElementById('btn-sleep').style.display = 'block';
        document.getElementById('btn-tear-camp').style.display = 'block';
    } else {
        document.getElementById('btn-sleep').style.display = 'none';
        document.getElementById('btn-tear-camp').style.display = 'none';
    }

    if (keys['KeyF']) { handleFeeding(); keys['KeyF'] = false; }

    camera.x = player.x - canvas.width / 2 + player.w / 2; camera.y = player.y - canvas.height / 2 + player.h / 2;
    camera.x = Math.max(0, Math.min(camera.x, CONFIG.WORLD_SIZE - canvas.width)); camera.y = Math.max(0, Math.min(camera.y, CONFIG.WORLD_SIZE - canvas.height));

    // Bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i]; b.update();
        if (b.dead || b.x < 0 || b.y < 0 || b.x > CONFIG.WORLD_SIZE || b.y > CONFIG.WORLD_SIZE) { bullets.splice(i, 1); continue; }
        for (let e of entities) {
            if (e.state !== STATE.DOWNED && e.state !== STATE.TAMED) {
                if(b.x < e.x + e.w && b.x + b.w > e.x && b.y < e.y + e.h && b.y + b.h > e.y) {
                    e.takeDamage(25, player); b.dead = true; bullets.splice(i, 1); break;
                }
            }
        }
    }
    
    // Shockwaves
    for (let i = shockwaves.length - 1; i >= 0; i--) {
        shockwaves[i].update(); if(shockwaves[i].dead) shockwaves.splice(i, 1);
    }

    let nearbyDowned = null, nearbyRide = null, hasCat = false, hasDog = false;

    entities.forEach((e) => {
        e.update();
        if (e.state === STATE.TAMED) {
            if (e.type === 'cat') hasCat = true; if (e.type === 'dog') hasDog = true;
            if (e.canRide && Math.hypot(player.x - e.x, player.y - e.y) < 60) nearbyRide = e;
        }
        if (e.state === STATE.DOWNED) {
            if (Math.hypot((player.x+player.w/2) - (e.x+e.w/2), (player.y+player.h/2) - (e.y+e.h/2)) < 80) nearbyDowned = e;
        } 
    });

    player.buffs.regen = hasCat;
    if (!hasDog) player.buffs.shield = false; else if (hasDog && !player.buffs.shield && Math.random() < 0.005) player.buffs.shield = true;
    if(player.buffs.regen && player.hp < 100) player.hp += 0.05;

    const menu = document.getElementById('action-menu');
    const downedMenu = document.getElementById('downed-actions');
    const tamedMenu = document.getElementById('tamed-actions');
    
    if (nearbyDowned) {
        interactionTarget = nearbyDowned;
        const screenX = (nearbyDowned.x + nearbyDowned.w/2) - camera.x; const screenY = nearbyDowned.y - camera.y;
        menu.style.display = 'flex'; menu.style.left = canvas.offsetLeft + screenX + 'px'; menu.style.top = canvas.offsetTop + screenY + 'px';
        document.getElementById('target-name').innerText = nearbyDowned.type.toUpperCase();
        downedMenu.style.display = 'flex'; tamedMenu.style.display = 'none';
    } else if (nearbyRide && !player.riding) {
        interactionTarget = nearbyRide;
        const screenX = (nearbyRide.x + nearbyRide.w/2) - camera.x; const screenY = nearbyRide.y - camera.y;
        menu.style.display = 'flex'; menu.style.left = canvas.offsetLeft + screenX + 'px'; menu.style.top = canvas.offsetTop + screenY + 'px';
        document.getElementById('target-name').innerText = nearbyRide.type.toUpperCase();
        downedMenu.style.display = 'none'; tamedMenu.style.display = 'flex';
    } else if (player.riding) {
         menu.style.display = 'none';
    } else {
        menu.style.display = 'none'; interactionTarget = null;
    }

    for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];
        if (Math.hypot(player.x - item.x, player.y - item.y) < 40) {
            if(item.type === 'meat') { player.inventory.meat++; showToast("+1 Meat"); items.splice(i, 1); }
        }
    }
    updateUI();
}

function startBuildCamp() {
    if (player.inventory.meat >= 5) {
        game.camp.x = player.x + 50; game.camp.y = player.y;
        game.camp.timer = 0; game.camp.building = true;
    } else { showToast("Need 5 Meat to build camp!"); }
}

function startTearCamp() {
    game.camp.timer = 0; game.camp.tearing = true;
}

function toggleSleep() {
    game.isNight = !game.isNight;
    showToast(game.isNight ? "Sleeping..." : "Waking up...");
}

function handleAction(action) {
    if (action === 'ride') {
        if (player.riding) {
             player.riding = null; showToast("Dismounted.");
        } else if (interactionTarget && interactionTarget.state === STATE.TAMED && interactionTarget.canRide) {
            player.riding = interactionTarget; interactionTarget.target = null;
            showToast(`Riding ${interactionTarget.type}! [SPACE] to Stomp.`);
        }
    }
    else if (interactionTarget && interactionTarget.state === STATE.DOWNED) {
        if (action === 'kill') { items.push(new Item('meat', interactionTarget.x, interactionTarget.y)); entities = entities.filter(e => e !== interactionTarget); showToast("Harvested Meat."); } 
        else if (action === 'tame') {
            if (Math.random() < CONFIG.TAME_CHANCE) {
                interactionTarget.state = STATE.TAMED; interactionTarget.hp = interactionTarget.maxHp; interactionTarget.target = null; showToast("Taming Success!");
            } else {
                showToast("Taming Failed..."); entities = entities.filter(e => e !== interactionTarget);
            }
        }
    }
    if (action !== 'ride') interactionTarget = null;
}

function handleFeeding() {
    if (player.inventory.meat <= 0) { showToast("No meat!"); return; }
    let closest = null, minDist = 150;
    entities.forEach(e => { if (e.state === STATE.TAMED && e.hp < e.maxHp) { const dist = Math.hypot((player.x) - (e.x), (player.y) - (e.y)); if (dist < minDist) { closest = e; minDist = dist; } } });
    if (closest) { player.inventory.meat--; closest.hp = Math.min(closest.hp + 50, closest.maxHp); showToast(`Fed ${closest.type}!`); } else { showToast("No injured pets nearby."); }
}

function updateUI() {
    document.getElementById('hp-bar').style.width = Math.max(0, player.hp) + '%';
    document.getElementById('meat-count').innerText = player.inventory.meat;
    const buffRow = document.getElementById('buff-row');
    let txt = []; if(player.buffs.shield) txt.push("SHIELD"); if(player.buffs.regen) txt.push("REGEN");
    if(txt.length > 0) { buffRow.style.display = 'flex'; document.getElementById('buff-text').innerText = txt.join(' + '); } else { buffRow.style.display = 'none'; }
    
    // Build Button Logic
    document.getElementById('btn-build-camp').disabled = game.camp.active || (player.inventory.meat < 5);
}

function showToast(msg) { const t = document.getElementById('toast'); t.innerText = msg; t.style.opacity = 1; setTimeout(() => t.style.opacity = 0, 2000); }

function gameOver() {
    gameActive = false;
    document.getElementById('game-over-screen').style.display = 'flex';
}

function draw() {
    ctx.fillStyle = '#2d5a27'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.save(); ctx.translate(-Math.floor(camera.x), -Math.floor(camera.y));
    if (worldCanvas) ctx.drawImage(worldCanvas, 0, 0);
    ctx.strokeStyle = '#3e2723'; ctx.lineWidth = 20; ctx.strokeRect(0, 0, CONFIG.WORLD_SIZE, CONFIG.WORLD_SIZE);

    if (game.camp.active) {
        let tTent = textures['tent'], tFire = textures['bonfire'], tChair = textures['chair'];
        // Spaced out camp elements
        ctx.drawImage(tTent.img, game.camp.x - 30, game.camp.y - 20, tTent.w*CONFIG.SCALE, tTent.h*CONFIG.SCALE);
        let flicker = Math.random()*5;
        ctx.drawImage(tFire.img, game.camp.x + 40 - flicker/2, game.camp.y + 20 - flicker/2, (tFire.w+flicker)*CONFIG.SCALE, (tFire.h+flicker)*CONFIG.SCALE);
        ctx.drawImage(tChair.img, game.camp.x + 80, game.camp.y + 10, tChair.w*CONFIG.SCALE, tChair.h*CONFIG.SCALE);
    }

    items.forEach(i => i.draw(ctx));
    shockwaves.forEach(s => s.draw(ctx));

    const renderList = [...entities, player, ...bullets];
    renderList.sort((a, b) => {
        let ay = a.y + (a.h||0);
        let by = b.y + (b.h||0);
        if (a === player.riding && b === player) return -1;
        if (b === player.riding && a === player) return 1;
        return ay - by;
    });

    renderList.forEach(obj => {
        if (obj instanceof Bullet) obj.draw(ctx);
        else if (obj === player) {
            let tex = textures[player.type];
            let sx = player.frame * tex.w, sy = player.dir * tex.h;
            if (player.buffs.shield) { ctx.fillStyle = 'rgba(241, 196, 15, 0.2)'; ctx.beginPath(); ctx.arc(player.x + player.w/2, player.y + player.h/2 + 5, player.w/1.5, 0, Math.PI*2); ctx.fill(); }
            if (player.buffs.regen) { ctx.fillStyle = 'rgba(46, 204, 113, 0.2)'; ctx.beginPath(); ctx.arc(player.x + player.w/2, player.y + player.h/2 + 5, player.w/1.5, 0, Math.PI*2); ctx.fill(); }
            ctx.drawImage(tex.img, sx, sy, tex.w, tex.h, player.x, player.y, player.w, player.h);
            if (game.isNight && !player.isMoving) { ctx.fillStyle = "#fff"; ctx.font="12px serif"; ctx.fillText("z", player.x+player.w, player.y); }
        }
        else if (obj.draw) obj.draw(ctx);
    });

    // Night Overlay (Smooth)
    if (game.nightAlpha > 0.01) {
        ctx.fillStyle = `rgba(0, 0, 40, ${game.nightAlpha})`; 
        ctx.fillRect(camera.x, camera.y, canvas.width, canvas.height); 
    }
    ctx.restore();
}

function gameLoop() { update(); draw(); requestAnimationFrame(gameLoop); }

window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);
document.querySelectorAll('.dpad-btn, #action-btn-mobile').forEach(btn => {
    const k = btn.dataset.key;
    btn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[k] = true; });
    btn.addEventListener('touchend', (e) => { e.preventDefault(); keys[k] = false; });
    btn.addEventListener('mousedown', () => keys[k] = true);
    btn.addEventListener('mouseup', () => keys[k] = false);
});
window.onload = () => { initTextures(); resizeCanvas(); generateWorld(); updatePlayerSprite(); };
</script>
</body>
</html>